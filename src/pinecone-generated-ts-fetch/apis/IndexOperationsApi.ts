/* tslint:disable */
/* eslint-disable */
/**
 * Pinecone API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CollectionMeta,
  CreateCollectionRequest,
  CreateRequest,
  IndexMeta,
  PatchRequest,
} from '../models';
import {
    CollectionMetaFromJSON,
    CollectionMetaToJSON,
    CreateCollectionRequestFromJSON,
    CreateCollectionRequestToJSON,
    CreateRequestFromJSON,
    CreateRequestToJSON,
    IndexMetaFromJSON,
    IndexMetaToJSON,
    PatchRequestFromJSON,
    PatchRequestToJSON,
} from '../models';

export interface ConfigureIndexRequest {
    indexName: string;
    patchRequest?: PatchRequest;
}

export interface CreateCollectionOperationRequest {
    createCollectionRequest?: CreateCollectionRequest;
}

export interface CreateIndexRequest {
    createRequest?: CreateRequest;
}

export interface DeleteCollectionRequest {
    collectionName: string;
}

export interface DeleteIndexRequest {
    indexName: string;
}

export interface DescribeCollectionRequest {
    collectionName: string;
}

export interface DescribeIndexRequest {
    indexName: string;
}

/**
 * IndexOperationsApi - interface
 * 
 * @export
 * @interface IndexOperationsApiInterface
 */
export interface IndexOperationsApiInterface {
    /**
     * This operation specifies the pod type and number of replicas for an index.
     * @param {string} indexName The name of the index
     * @param {PatchRequest} [patchRequest] The desired pod type and replica configuration for the index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    configureIndexRaw(requestParameters: ConfigureIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * This operation specifies the pod type and number of replicas for an index.
     */
    configureIndex(requestParameters: ConfigureIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * This operation creates a Pinecone collection.
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    createCollectionRaw(requestParameters: CreateCollectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * This operation creates a Pinecone collection.
     */
    createCollection(requestParameters: CreateCollectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
     * @param {CreateRequest} [createRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    createIndexRaw(requestParameters: CreateIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
     */
    createIndex(requestParameters: CreateIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * This operation deletes an existing collection.
     * @param {string} collectionName The name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    deleteCollectionRaw(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * This operation deletes an existing collection.
     */
    deleteCollection(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * This operation deletes an existing index.
     * @param {string} indexName The name of the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    deleteIndexRaw(requestParameters: DeleteIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>>;

    /**
     * This operation deletes an existing index.
     */
    deleteIndex(requestParameters: DeleteIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string>;

    /**
     * Get a description of a collection.
     * @param {string} collectionName The name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    describeCollectionRaw(requestParameters: DescribeCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionMeta>>;

    /**
     * Get a description of a collection.
     */
    describeCollection(requestParameters: DescribeCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionMeta>;

    /**
     * Get a description of an index.
     * @param {string} indexName The name of the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    describeIndexRaw(requestParameters: DescribeIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexMeta>>;

    /**
     * Get a description of an index.
     */
    describeIndex(requestParameters: DescribeIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexMeta>;

    /**
     * This operation returns a list of your Pinecone collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    listCollectionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * This operation returns a list of your Pinecone collections.
     */
    listCollections(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>>;

    /**
     * This operation returns a list of your Pinecone indexes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApiInterface
     */
    listIndexesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>>;

    /**
     * This operation returns a list of your Pinecone indexes.
     */
    listIndexes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>>;

}

/**
 * 
 */
export class IndexOperationsApi extends runtime.BaseAPI implements IndexOperationsApiInterface {

    /**
     * This operation specifies the pod type and number of replicas for an index.
     */
    async configureIndexRaw(requestParameters: ConfigureIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName','Required parameter requestParameters.indexName was null or undefined when calling configureIndex.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/databases/{indexName}`.replace(`{${"indexName"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchRequestToJSON(requestParameters.patchRequest),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This operation specifies the pod type and number of replicas for an index.
     */
    async configureIndex(requestParameters: ConfigureIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.configureIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation creates a Pinecone collection.
     */
    async createCollectionRaw(requestParameters: CreateCollectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/collections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCollectionRequestToJSON(requestParameters.createCollectionRequest),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This operation creates a Pinecone collection.
     */
    async createCollection(requestParameters: CreateCollectionOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
     */
    async createIndexRaw(requestParameters: CreateIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/databases`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRequestToJSON(requestParameters.createRequest),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
     */
    async createIndex(requestParameters: CreateIndexRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation deletes an existing collection.
     */
    async deleteCollectionRaw(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This operation deletes an existing collection.
     */
    async deleteCollection(requestParameters: DeleteCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.deleteCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation deletes an existing index.
     */
    async deleteIndexRaw(requestParameters: DeleteIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName','Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/databases/{indexName}`.replace(`{${"indexName"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This operation deletes an existing index.
     */
    async deleteIndex(requestParameters: DeleteIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.deleteIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a description of a collection.
     */
    async describeCollectionRaw(requestParameters: DescribeCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CollectionMeta>> {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName','Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/collections/{collectionName}`.replace(`{${"collectionName"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CollectionMetaFromJSON(jsonValue));
    }

    /**
     * Get a description of a collection.
     */
    async describeCollection(requestParameters: DescribeCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CollectionMeta> {
        const response = await this.describeCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a description of an index.
     */
    async describeIndexRaw(requestParameters: DescribeIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexMeta>> {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName','Required parameter requestParameters.indexName was null or undefined when calling describeIndex.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/databases/{indexName}`.replace(`{${"indexName"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexMetaFromJSON(jsonValue));
    }

    /**
     * Get a description of an index.
     */
    async describeIndex(requestParameters: DescribeIndexRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexMeta> {
        const response = await this.describeIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation returns a list of your Pinecone collections.
     */
    async listCollectionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/collections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This operation returns a list of your Pinecone collections.
     */
    async listCollections(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.listCollectionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * This operation returns a list of your Pinecone indexes.
     */
    async listIndexesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/databases`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This operation returns a list of your Pinecone indexes.
     */
    async listIndexes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.listIndexesRaw(initOverrides);
        return await response.value();
    }

}
