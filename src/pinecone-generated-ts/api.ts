/* tslint:disable */
/* eslint-disable */
/**
 * Pinecone API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApproximatedConfig
 */
export interface ApproximatedConfig {
    /**
     * 
     * @type {number}
     * @memberof ApproximatedConfig
     */
    'k_bits'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApproximatedConfig
     */
    'hybrid'?: boolean;
}
/**
 * 
 * @export
 * @interface CollectionMeta
 */
export interface CollectionMeta {
    /**
     * 
     * @type {string}
     * @memberof CollectionMeta
     */
    'name'?: string;
    /**
     * The size of the collection in bytes.
     * @type {number}
     * @memberof CollectionMeta
     */
    'size'?: number;
    /**
     * The status of the collection.
     * @type {string}
     * @memberof CollectionMeta
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * The name of the collection to be created.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'name': string;
    /**
     * The name of the source index to be used as the source for the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    'source': string;
}
/**
 * 
 * @export
 * @interface CreateRequest
 */
export interface CreateRequest {
    /**
     * The name of the index to be created. The maximum length is 45 characters.
     * @type {string}
     * @memberof CreateRequest
     */
    'name': string;
    /**
     * The dimensions of the vectors to be inserted in the index
     * @type {number}
     * @memberof CreateRequest
     */
    'dimension': number;
    /**
     * The type of vector index. Pinecone supports \'approximated\'.
     * @type {string}
     * @memberof CreateRequest
     * @deprecated
     */
    'index_type'?: string;
    /**
     * The distance metric to be used for similarity search. You can use \'euclidean\', \'cosine\', or \'dotproduct\'.
     * @type {string}
     * @memberof CreateRequest
     */
    'metric'?: string;
    /**
     * The number of pods for the index to use,including replicas.
     * @type {number}
     * @memberof CreateRequest
     */
    'pods'?: number;
    /**
     * The number of replicas. Replicas duplicate your index. They provide higher availability and throughput.
     * @type {number}
     * @memberof CreateRequest
     */
    'replicas'?: number;
    /**
     * The number of shards to be used in the index.
     * @type {number}
     * @memberof CreateRequest
     */
    'shards'?: number;
    /**
     * The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
     * @type {string}
     * @memberof CreateRequest
     */
    'pod_type'?: string;
    /**
     * 
     * @type {CreateRequestIndexConfig}
     * @memberof CreateRequest
     * @deprecated
     */
    'index_config'?: CreateRequestIndexConfig;
    /**
     * Configuration for the behavior of Pinecone\'s internal metadata index. By default, all metadata is indexed; when `metadata_config` is present, only specified metadata fields are indexed. To specify metadata fields to index, provide a JSON object of the following form:    ```   {\"indexed\": [\"example_metadata_field\"]}   ``` 
     * @type {object}
     * @memberof CreateRequest
     */
    'metadata_config'?: object | null;
    /**
     * The name of the collection to create an index from
     * @type {string}
     * @memberof CreateRequest
     */
    'source_collection'?: string;
}
/**
 * @type CreateRequestIndexConfig
 * @export
 */
export type CreateRequestIndexConfig = ApproximatedConfig;

/**
 * The request for the `Delete` operation.
 * @export
 * @interface DeleteRequest
 */
export interface DeleteRequest {
    /**
     * Vectors to delete.
     * @type {Array<string>}
     * @memberof DeleteRequest
     */
    'ids'?: Array<string>;
    /**
     * This indicates that all vectors in the index namespace should be deleted.
     * @type {boolean}
     * @memberof DeleteRequest
     */
    'deleteAll'?: boolean;
    /**
     * The namespace to delete vectors from, if applicable.
     * @type {string}
     * @memberof DeleteRequest
     */
    'namespace'?: string;
    /**
     * If specified, the metadata filter here will be used to select the vectors to delete. This is mutually exclusive with specifying ids to delete in the ids param or using delete_all=True. See https://www.pinecone.io/docs/metadata-filtering/.
     * @type {object}
     * @memberof DeleteRequest
     */
    'filter'?: object;
}
/**
 * The request for the `DescribeIndexStats` operation.
 * @export
 * @interface DescribeIndexStatsRequest
 */
export interface DescribeIndexStatsRequest {
    /**
     * If this parameter is present, the operation only returns statistics for vectors that satisfy the filter. See https://www.pinecone.io/docs/metadata-filtering/.
     * @type {object}
     * @memberof DescribeIndexStatsRequest
     */
    'filter'?: object;
}
/**
 * The response for the `DescribeIndexStats` operation.
 * @export
 * @interface DescribeIndexStatsResponse
 */
export interface DescribeIndexStatsResponse {
    /**
     * A mapping for each namespace in the index from the namespace name to a summary of its contents. If a metadata filter expression is present, the summary will reflect only vectors matching that expression.
     * @type {{ [key: string]: NamespaceSummary; }}
     * @memberof DescribeIndexStatsResponse
     */
    'namespaces'?: { [key: string]: NamespaceSummary; };
    /**
     * The dimension of the indexed vectors.
     * @type {number}
     * @memberof DescribeIndexStatsResponse
     */
    'dimension'?: number;
    /**
     * The fullness of the index, regardless of whether a metadata filter expression was passed. The granularity of this metric is 10%.
     * @type {number}
     * @memberof DescribeIndexStatsResponse
     */
    'indexFullness'?: number;
    /**
     * 
     * @type {number}
     * @memberof DescribeIndexStatsResponse
     */
    'totalVectorCount'?: number;
}
/**
 * The response for the `Fetch` operation.
 * @export
 * @interface FetchResponse
 */
export interface FetchResponse {
    /**
     * 
     * @type {{ [key: string]: Vector; }}
     * @memberof FetchResponse
     */
    'vectors'?: { [key: string]: Vector; };
    /**
     * The namespace of the vectors.
     * @type {string}
     * @memberof FetchResponse
     */
    'namespace'?: string;
}
/**
 * 
 * @export
 * @interface HnswConfig
 */
export interface HnswConfig {
    /**
     * 
     * @type {number}
     * @memberof HnswConfig
     */
    'ef_construction'?: number;
    /**
     * 
     * @type {number}
     * @memberof HnswConfig
     */
    'ef'?: number;
    /**
     * 
     * @type {number}
     * @memberof HnswConfig
     */
    'M'?: number;
    /**
     * 
     * @type {number}
     * @memberof HnswConfig
     */
    'max_elements'?: number;
}
/**
 * 
 * @export
 * @interface IndexMeta
 */
export interface IndexMeta {
    /**
     * 
     * @type {IndexMetaDatabase}
     * @memberof IndexMeta
     */
    'database'?: IndexMetaDatabase;
}
/**
 * 
 * @export
 * @interface IndexMetaDatabase
 */
export interface IndexMetaDatabase {
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabase
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabase
     */
    'dimensions'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabase
     * @deprecated
     */
    'index_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabase
     */
    'metric'?: string;
    /**
     * 
     * @type {number}
     * @memberof IndexMetaDatabase
     */
    'pods'?: number;
    /**
     * 
     * @type {number}
     * @memberof IndexMetaDatabase
     */
    'replicas'?: number;
    /**
     * 
     * @type {number}
     * @memberof IndexMetaDatabase
     */
    'shards'?: number;
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabase
     */
    'pod_type'?: string;
    /**
     * 
     * @type {IndexMetaDatabaseIndexConfig}
     * @memberof IndexMetaDatabase
     */
    'index_config'?: IndexMetaDatabaseIndexConfig;
    /**
     * 
     * @type {IndexMetaDatabaseStatus}
     * @memberof IndexMetaDatabase
     */
    'status'?: IndexMetaDatabaseStatus;
}
/**
 * @type IndexMetaDatabaseIndexConfig
 * @export
 */
export type IndexMetaDatabaseIndexConfig = ApproximatedConfig;

/**
 * 
 * @export
 * @interface IndexMetaDatabaseStatus
 */
export interface IndexMetaDatabaseStatus {
    /**
     * 
     * @type {boolean}
     * @memberof IndexMetaDatabaseStatus
     */
    'ready'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IndexMetaDatabaseStatus
     */
    'state'?: IndexMetaDatabaseStatusStateEnum;
}

export const IndexMetaDatabaseStatusStateEnum = {
    Initializing: 'Initializing',
    ScalingUp: 'ScalingUp',
    ScalingDown: 'ScalingDown',
    Terminating: 'Terminating',
    Ready: 'Ready'
} as const;

export type IndexMetaDatabaseStatusStateEnum = typeof IndexMetaDatabaseStatusStateEnum[keyof typeof IndexMetaDatabaseStatusStateEnum];

/**
 * A summary of the contents of a namespace.
 * @export
 * @interface NamespaceSummary
 */
export interface NamespaceSummary {
    /**
     * The number of vectors stored in this namespace. Note that updates to this field may lag behind updates to the underlying index and corresponding query results, etc.
     * @type {number}
     * @memberof NamespaceSummary
     */
    'vectorCount'?: number;
}
/**
 * 
 * @export
 * @interface PatchRequest
 */
export interface PatchRequest {
    /**
     * The desired number of replicas for the index.
     * @type {number}
     * @memberof PatchRequest
     */
    'replicas'?: number;
    /**
     * The new pod type for the index. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
     * @type {string}
     * @memberof PatchRequest
     */
    'pod_type'?: string;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'typeUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    'value'?: string;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */

export const ProtobufNullValue = {
    NullValue: 'NULL_VALUE'
} as const;

export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];


/**
 * The request for the `Query` operation.
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * The namespace to query.
     * @type {string}
     * @memberof QueryRequest
     */
    'namespace'?: string;
    /**
     * The number of results to return for each query.
     * @type {number}
     * @memberof QueryRequest
     */
    'topK': number;
    /**
     * The filter to apply. You can use vector metadata to limit your search. See https://www.pinecone.io/docs/metadata-filtering/.
     * @type {object}
     * @memberof QueryRequest
     */
    'filter'?: object;
    /**
     * Indicates whether vector values are included in the response.
     * @type {boolean}
     * @memberof QueryRequest
     */
    'includeValues'?: boolean;
    /**
     * Indicates whether metadata is included in the response as well as the ids.
     * @type {boolean}
     * @memberof QueryRequest
     */
    'includeMetadata'?: boolean;
    /**
     * DEPRECATED. The query vectors. Each `query()` request can contain only one of the parameters `queries`, `vector`, or  `id`.
     * @type {Array<QueryVector>}
     * @memberof QueryRequest
     * @deprecated
     */
    'queries'?: Array<QueryVector>;
    /**
     * The query vector. This should be the same length as the dimension of the index being queried. Each `query()` request can contain only one of the parameters `id` or `vector`.
     * @type {Array<number>}
     * @memberof QueryRequest
     */
    'vector'?: Array<number>;
    /**
     * The unique ID of the vector to be used as a query vector. Each `query()` request can contain only one of the parameters `queries`, `vector`, or  `id`.
     * @type {string}
     * @memberof QueryRequest
     */
    'id'?: string;
}
/**
 * The response for the `Query` operation. These are the matches found for a particular query vector. The matches are ordered from most similar to least similar.
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * DEPRECATED. The results of each query. The order is the same as `QueryRequest.queries`.
     * @type {Array<SingleQueryResults>}
     * @memberof QueryResponse
     * @deprecated
     */
    'results'?: Array<SingleQueryResults>;
    /**
     * The matches for the vectors.
     * @type {Array<ScoredVector>}
     * @memberof QueryResponse
     */
    'matches'?: Array<ScoredVector>;
    /**
     * The namespace for the vectors.
     * @type {string}
     * @memberof QueryResponse
     */
    'namespace'?: string;
}
/**
 * A single query vector within a `QueryRequest`.
 * @export
 * @interface QueryVector
 */
export interface QueryVector {
    /**
     * The query vector values. This should be the same length as the dimension of the index being queried.
     * @type {Array<number>}
     * @memberof QueryVector
     */
    'values': Array<number>;
    /**
     * An override for the number of results to return for this query vector.
     * @type {number}
     * @memberof QueryVector
     */
    'topK'?: number;
    /**
     * An override the namespace to search.
     * @type {string}
     * @memberof QueryVector
     */
    'namespace'?: string;
    /**
     * An override for the metadata filter to apply. This replaces the request-level filter.
     * @type {object}
     * @memberof QueryVector
     */
    'filter'?: object;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface ScoredVector
 */
export interface ScoredVector {
    /**
     * This is the vector\'s unique id.
     * @type {string}
     * @memberof ScoredVector
     */
    'id': string;
    /**
     * This is a measure of similarity between this vector and the query vector.  The higher the score, the more they are similar.
     * @type {number}
     * @memberof ScoredVector
     */
    'score'?: number;
    /**
     * This is the vector data, if it is requested.
     * @type {Array<number>}
     * @memberof ScoredVector
     */
    'values'?: Array<number>;
    /**
     * This is the metadata, if it is requested.
     * @type {object}
     * @memberof ScoredVector
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface SingleQueryResults
 */
export interface SingleQueryResults {
    /**
     * The matches for the vectors.
     * @type {Array<ScoredVector>}
     * @memberof SingleQueryResults
     */
    'matches'?: Array<ScoredVector>;
    /**
     * The namespace for the vectors.
     * @type {string}
     * @memberof SingleQueryResults
     */
    'namespace'?: string;
}
/**
 * The request for the `Upsert` operation.
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
    /**
     * Vector\'s unique id.
     * @type {string}
     * @memberof UpdateRequest
     */
    'id': string;
    /**
     * Vector data.
     * @type {Array<number>}
     * @memberof UpdateRequest
     */
    'values'?: Array<number>;
    /**
     * Metadata to *set* for the vector.
     * @type {object}
     * @memberof UpdateRequest
     */
    'setMetadata'?: object;
    /**
     * Namespace name where to update the vector.
     * @type {string}
     * @memberof UpdateRequest
     */
    'namespace'?: string;
}
/**
 * The request for the `Upsert` operation.
 * @export
 * @interface UpsertRequest
 */
export interface UpsertRequest {
    /**
     * An array containing the vectors to upsert. Recommended batch limit is 100 vectors.
     * @type {Array<Vector>}
     * @memberof UpsertRequest
     */
    'vectors': Array<Vector>;
    /**
     * This is the namespace name where you upsert vectors.
     * @type {string}
     * @memberof UpsertRequest
     */
    'namespace'?: string;
}
/**
 * The response for the `Upsert` operation.
 * @export
 * @interface UpsertResponse
 */
export interface UpsertResponse {
    /**
     * The number of vectors upserted.
     * @type {number}
     * @memberof UpsertResponse
     */
    'upsertedCount'?: number;
}
/**
 * 
 * @export
 * @interface Vector
 */
export interface Vector {
    /**
     * This is the vector\'s unique id.
     * @type {string}
     * @memberof Vector
     */
    'id': string;
    /**
     * This is the vector data included in the request.
     * @type {Array<number>}
     * @memberof Vector
     */
    'values': Array<number>;
    /**
     * This is the metadata included in the request.
     * @type {object}
     * @memberof Vector
     */
    'metadata'?: object;
}

/**
 * IndexOperationsApi - axios parameter creator
 * @export
 */
export const IndexOperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation specifies the pod type and number of replicas for an index.
         * @param {string} indexName The name of the index
         * @param {PatchRequest} [patchRequest] The desired pod type and replica configuration for the index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureIndex: async (indexName: string, patchRequest?: PatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexName' is not null or undefined
            assertParamExists('configureIndex', 'indexName', indexName)
            const localVarPath = `/databases/{indexName}`
                .replace(`{${"indexName"}}`, encodeURIComponent(String(indexName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation creates a Pinecone collection.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (createCollectionRequest?: CreateCollectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
         * @param {CreateRequest} [createRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex: async (createRequest?: CreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation deletes an existing collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation deletes an existing index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIndex: async (indexName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexName' is not null or undefined
            assertParamExists('deleteIndex', 'indexName', indexName)
            const localVarPath = `/databases/{indexName}`
                .replace(`{${"indexName"}}`, encodeURIComponent(String(indexName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a description of a collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeCollection: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('describeCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collectionName}`
                .replace(`{${"collectionName"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a description of an index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndex: async (indexName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'indexName' is not null or undefined
            assertParamExists('describeIndex', 'indexName', indexName)
            const localVarPath = `/databases/{indexName}`
                .replace(`{${"indexName"}}`, encodeURIComponent(String(indexName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation returns a list of your Pinecone collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation returns a list of your Pinecone indexes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIndexes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/databases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndexOperationsApi - functional programming interface
 * @export
 */
export const IndexOperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IndexOperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation specifies the pod type and number of replicas for an index.
         * @param {string} indexName The name of the index
         * @param {PatchRequest} [patchRequest] The desired pod type and replica configuration for the index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configureIndex(indexName: string, patchRequest?: PatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configureIndex(indexName, patchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation creates a Pinecone collection.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(createCollectionRequest?: CreateCollectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(createCollectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
         * @param {CreateRequest} [createRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIndex(createRequest?: CreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIndex(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation deletes an existing collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation deletes an existing index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIndex(indexName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIndex(indexName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a description of a collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeCollection(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeCollection(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a description of an index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeIndex(indexName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeIndex(indexName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation returns a list of your Pinecone collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCollections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCollections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This operation returns a list of your Pinecone indexes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIndexes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIndexes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IndexOperationsApi - factory interface
 * @export
 */
export const IndexOperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IndexOperationsApiFp(configuration)
    return {
        /**
         * This operation specifies the pod type and number of replicas for an index.
         * @param {string} indexName The name of the index
         * @param {PatchRequest} [patchRequest] The desired pod type and replica configuration for the index.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configureIndex(indexName: string, patchRequest?: PatchRequest, options?: any): AxiosPromise<string> {
            return localVarFp.configureIndex(indexName, patchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation creates a Pinecone collection.
         * @param {CreateCollectionRequest} [createCollectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(createCollectionRequest?: CreateCollectionRequest, options?: any): AxiosPromise<string> {
            return localVarFp.createCollection(createCollectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
         * @param {CreateRequest} [createRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(createRequest?: CreateRequest, options?: any): AxiosPromise<string> {
            return localVarFp.createIndex(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation deletes an existing collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation deletes an existing index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIndex(indexName: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteIndex(indexName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a description of a collection.
         * @param {string} collectionName The name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeCollection(collectionName: string, options?: any): AxiosPromise<CollectionMeta> {
            return localVarFp.describeCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a description of an index.
         * @param {string} indexName The name of the index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndex(indexName: string, options?: any): AxiosPromise<IndexMeta> {
            return localVarFp.describeIndex(indexName, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation returns a list of your Pinecone collections.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * This operation returns a list of your Pinecone indexes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIndexes(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listIndexes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IndexOperationsApi - object-oriented interface
 * @export
 * @class IndexOperationsApi
 * @extends {BaseAPI}
 */
export class IndexOperationsApi extends BaseAPI {
    /**
     * This operation specifies the pod type and number of replicas for an index.
     * @param {string} indexName The name of the index
     * @param {PatchRequest} [patchRequest] The desired pod type and replica configuration for the index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public configureIndex(indexName: string, patchRequest?: PatchRequest, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).configureIndex(indexName, patchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation creates a Pinecone collection.
     * @param {CreateCollectionRequest} [createCollectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public createCollection(createCollectionRequest?: CreateCollectionRequest, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).createCollection(createCollectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation creates a Pinecone index. You can use it to specify the measure of similarity, the dimension of vectors to be stored in the index, the numbers of shards and replicas to use, and more.
     * @param {CreateRequest} [createRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public createIndex(createRequest?: CreateRequest, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).createIndex(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation deletes an existing collection.
     * @param {string} collectionName The name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public deleteCollection(collectionName: string, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).deleteCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation deletes an existing index.
     * @param {string} indexName The name of the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public deleteIndex(indexName: string, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).deleteIndex(indexName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a description of a collection.
     * @param {string} collectionName The name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public describeCollection(collectionName: string, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).describeCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a description of an index.
     * @param {string} indexName The name of the index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public describeIndex(indexName: string, options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).describeIndex(indexName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation returns a list of your Pinecone collections.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public listCollections(options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).listCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation returns a list of your Pinecone indexes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexOperationsApi
     */
    public listIndexes(options?: AxiosRequestConfig) {
        return IndexOperationsApiFp(this.configuration).listIndexes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VectorOperationsApi - axios parameter creator
 * @export
 */
export const VectorOperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {DeleteRequest} deleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (deleteRequest: DeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteRequest' is not null or undefined
            assertParamExists('_delete', 'deleteRequest', deleteRequest)
            const localVarPath = `/vectors/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {Array<string>} [ids] Vectors to delete.
         * @param {boolean} [deleteAll] This indicates that all vectors in the index namespace should be deleted.
         * @param {string} [namespace] The namespace to delete vectors from, if applicable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (ids?: Array<string>, deleteAll?: boolean, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vectors/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (deleteAll !== undefined) {
                localVarQueryParameter['deleteAll'] = deleteAll;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {DescribeIndexStatsRequest} describeIndexStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndexStats: async (describeIndexStatsRequest: DescribeIndexStatsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'describeIndexStatsRequest' is not null or undefined
            assertParamExists('describeIndexStats', 'describeIndexStatsRequest', describeIndexStatsRequest)
            const localVarPath = `/describe_index_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(describeIndexStatsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndexStats1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/describe_index_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `Fetch` operation looks up and returns vectors, by ID, from a single namespace. The returned vectors include the vector data and/or metadata.
         * @summary Fetch
         * @param {Array<string>} ids The vector IDs to fetch. Does not accept values containing spaces.
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch: async (ids: Array<string>, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('fetch', 'ids', ids)
            const localVarPath = `/vectors/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `Query` operation searches a namespace, using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.
         * @summary Query
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query: async (queryRequest: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryRequest' is not null or undefined
            assertParamExists('query', 'queryRequest', queryRequest)
            const localVarPath = `/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `Update` operation updates vector in a namespace. If a value is included, it will overwrite the previous value. If a set_metadata is included, the values of the fields specified in it will be added or overwrite the previous value.
         * @summary Update
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (updateRequest: UpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('update', 'updateRequest', updateRequest)
            const localVarPath = `/vectors/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `Upsert` operation writes vectors into a namespace. If a new value is upserted for an existing vector id, it will overwrite the previous value.
         * @summary Upsert
         * @param {UpsertRequest} upsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsert: async (upsertRequest: UpsertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertRequest' is not null or undefined
            assertParamExists('upsert', 'upsertRequest', upsertRequest)
            const localVarPath = `/vectors/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VectorOperationsApi - functional programming interface
 * @export
 */
export const VectorOperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VectorOperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {DeleteRequest} deleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(deleteRequest: DeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(deleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {Array<string>} [ids] Vectors to delete.
         * @param {boolean} [deleteAll] This indicates that all vectors in the index namespace should be deleted.
         * @param {string} [namespace] The namespace to delete vectors from, if applicable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(ids?: Array<string>, deleteAll?: boolean, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(ids, deleteAll, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {DescribeIndexStatsRequest} describeIndexStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeIndexStats(describeIndexStatsRequest: DescribeIndexStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DescribeIndexStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeIndexStats(describeIndexStatsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async describeIndexStats1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DescribeIndexStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.describeIndexStats1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `Fetch` operation looks up and returns vectors, by ID, from a single namespace. The returned vectors include the vector data and/or metadata.
         * @summary Fetch
         * @param {Array<string>} ids The vector IDs to fetch. Does not accept values containing spaces.
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetch(ids: Array<string>, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetch(ids, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `Query` operation searches a namespace, using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.
         * @summary Query
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async query(queryRequest: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.query(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `Update` operation updates vector in a namespace. If a value is included, it will overwrite the previous value. If a set_metadata is included, the values of the fields specified in it will be added or overwrite the previous value.
         * @summary Update
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(updateRequest: UpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The `Upsert` operation writes vectors into a namespace. If a new value is upserted for an existing vector id, it will overwrite the previous value.
         * @summary Upsert
         * @param {UpsertRequest} upsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsert(upsertRequest: UpsertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpsertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsert(upsertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VectorOperationsApi - factory interface
 * @export
 */
export const VectorOperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VectorOperationsApiFp(configuration)
    return {
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {DeleteRequest} deleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(deleteRequest: DeleteRequest, options?: any): AxiosPromise<object> {
            return localVarFp._delete(deleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
         * @summary Delete
         * @param {Array<string>} [ids] Vectors to delete.
         * @param {boolean} [deleteAll] This indicates that all vectors in the index namespace should be deleted.
         * @param {string} [namespace] The namespace to delete vectors from, if applicable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(ids?: Array<string>, deleteAll?: boolean, namespace?: string, options?: any): AxiosPromise<object> {
            return localVarFp.delete1(ids, deleteAll, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {DescribeIndexStatsRequest} describeIndexStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndexStats(describeIndexStatsRequest: DescribeIndexStatsRequest, options?: any): AxiosPromise<DescribeIndexStatsResponse> {
            return localVarFp.describeIndexStats(describeIndexStatsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
         * @summary DescribeIndexStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeIndexStats1(options?: any): AxiosPromise<DescribeIndexStatsResponse> {
            return localVarFp.describeIndexStats1(options).then((request) => request(axios, basePath));
        },
        /**
         * The `Fetch` operation looks up and returns vectors, by ID, from a single namespace. The returned vectors include the vector data and/or metadata.
         * @summary Fetch
         * @param {Array<string>} ids The vector IDs to fetch. Does not accept values containing spaces.
         * @param {string} [namespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetch(ids: Array<string>, namespace?: string, options?: any): AxiosPromise<FetchResponse> {
            return localVarFp.fetch(ids, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * The `Query` operation searches a namespace, using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.
         * @summary Query
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(queryRequest: QueryRequest, options?: any): AxiosPromise<QueryResponse> {
            return localVarFp.query(queryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `Update` operation updates vector in a namespace. If a value is included, it will overwrite the previous value. If a set_metadata is included, the values of the fields specified in it will be added or overwrite the previous value.
         * @summary Update
         * @param {UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(updateRequest: UpdateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.update(updateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `Upsert` operation writes vectors into a namespace. If a new value is upserted for an existing vector id, it will overwrite the previous value.
         * @summary Upsert
         * @param {UpsertRequest} upsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsert(upsertRequest: UpsertRequest, options?: any): AxiosPromise<UpsertResponse> {
            return localVarFp.upsert(upsertRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VectorOperationsApi - object-oriented interface
 * @export
 * @class VectorOperationsApi
 * @extends {BaseAPI}
 */
export class VectorOperationsApi extends BaseAPI {
    /**
     * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
     * @summary Delete
     * @param {DeleteRequest} deleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public _delete(deleteRequest: DeleteRequest, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration)._delete(deleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `Delete` operation deletes vectors, by id, from a single namespace. You can delete items by their id, from a single namespace.
     * @summary Delete
     * @param {Array<string>} [ids] Vectors to delete.
     * @param {boolean} [deleteAll] This indicates that all vectors in the index namespace should be deleted.
     * @param {string} [namespace] The namespace to delete vectors from, if applicable.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public delete1(ids?: Array<string>, deleteAll?: boolean, namespace?: string, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).delete1(ids, deleteAll, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
     * @summary DescribeIndexStats
     * @param {DescribeIndexStatsRequest} describeIndexStatsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public describeIndexStats(describeIndexStatsRequest: DescribeIndexStatsRequest, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).describeIndexStats(describeIndexStatsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `DescribeIndexStats` operation returns statistics about the index\'s contents, including the vector count per namespace, the number of dimensions, and the index fullness. The index fullness result  may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://www.pinecone.io/docs/api/operation/describe_index/).
     * @summary DescribeIndexStats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public describeIndexStats1(options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).describeIndexStats1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `Fetch` operation looks up and returns vectors, by ID, from a single namespace. The returned vectors include the vector data and/or metadata.
     * @summary Fetch
     * @param {Array<string>} ids The vector IDs to fetch. Does not accept values containing spaces.
     * @param {string} [namespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public fetch(ids: Array<string>, namespace?: string, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).fetch(ids, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `Query` operation searches a namespace, using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.
     * @summary Query
     * @param {QueryRequest} queryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public query(queryRequest: QueryRequest, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).query(queryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `Update` operation updates vector in a namespace. If a value is included, it will overwrite the previous value. If a set_metadata is included, the values of the fields specified in it will be added or overwrite the previous value.
     * @summary Update
     * @param {UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public update(updateRequest: UpdateRequest, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).update(updateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `Upsert` operation writes vectors into a namespace. If a new value is upserted for an existing vector id, it will overwrite the previous value.
     * @summary Upsert
     * @param {UpsertRequest} upsertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorOperationsApi
     */
    public upsert(upsertRequest: UpsertRequest, options?: AxiosRequestConfig) {
        return VectorOperationsApiFp(this.configuration).upsert(upsertRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


